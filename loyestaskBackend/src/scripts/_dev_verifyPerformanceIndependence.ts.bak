/**
 * AN√ÅLISIS DE INTEGRIDAD DEL SISTEMA DE EVALUACI√ìN INDIVIDUAL
 * 
 * Este script verifica que las evaluaciones de desempe√±o sean completamente
 * independientes entre colaboradores y que los retrasos de un usuario no
 * afecten a otros miembros del proyecto.
 */

import dotenv from 'dotenv';
import colors from 'colors';
import mongoose from 'mongoose';
import Task from '../models/Task';
import UserPerformance from '../models/UserPerformance';
import UserEvaluation from '../models/UserEvaluation';
import User from '../models/User';
import Project from '../models/Project';

dotenv.config();

interface IndependenceAnalysis {
  taskAssignmentIntegrity: boolean;
  performanceTrackingIsolation: boolean;
  evaluationCalculationIndependence: boolean;
  crossUserImpactDetection: boolean;
  dataConsistencyCheck: boolean;
  overall: boolean;
  issues: string[];
  recommendations: string[];
  report: {
    totalTasks: number;
    tasksWithMultipleCollaborators: number;
    performanceRecordsAnalyzed: number;
    evaluationsAnalyzed: number;
    isolationViolations: number;
  };
}

class PerformanceIndependenceValidator {
  private analysis: IndependenceAnalysis = {
    taskAssignmentIntegrity: false,
    performanceTrackingIsolation: false,
    evaluationCalculationIndependence: false,
    crossUserImpactDetection: false,
    dataConsistencyCheck: false,
    overall: false,
    issues: [],
    recommendations: [],
    report: {
      totalTasks: 0,
      tasksWithMultipleCollaborators: 0,
      performanceRecordsAnalyzed: 0,
      evaluationsAnalyzed: 0,
      isolationViolations: 0
    }
  };

  async runAnalysis(): Promise<IndependenceAnalysis> {
    console.log(colors.magenta.bold('üîç AN√ÅLISIS DE INTEGRIDAD: EVALUACIONES INDIVIDUALES\n'));

    try {
      // Conectar a MongoDB
      await mongoose.connect(process.env.DATABASE_URL || '');
      console.log('‚úÖ Conectado a MongoDB\n');

      await this.analyzeTaskAssignmentIntegrity();
      await this.analyzePerformanceTrackingIsolation();
      await this.analyzeEvaluationCalculationIndependence();
      await this.detectCrossUserImpact();
      await this.checkDataConsistency();
      
      this.calculateOverallScore();
      this.printDetailedReport();
      
      await mongoose.disconnect();
      return this.analysis;

    } catch (error) {
      console.error('‚ùå Error en an√°lisis:', error);
      this.analysis.issues.push(`Error cr√≠tico: ${error.message}`);
      return this.analysis;
    }
  }

  /**
   * 1. Verificar integridad de asignaci√≥n de tareas
   */
  private async analyzeTaskAssignmentIntegrity(): Promise<void> {
    console.log('üìã 1. Analizando integridad de asignaci√≥n de tareas...');

    try {
      const tasks = await Task.find({}).populate('collaborators', 'name email');
      this.analysis.report.totalTasks = tasks.length;

      let hasIntegrity = true;
      let multiCollaboratorTasks = 0;

      for (const task of tasks) {
        if (task.collaborators && task.collaborators.length > 1) {
          multiCollaboratorTasks++;
        }

        // Verificar que cada colaborador est√© registrado individualmente
        if (task.collaborators && task.collaborators.length > 0) {
          for (const collaborator of task.collaborators) {
            const collaboratorId = typeof collaborator === 'string' ? collaborator : (collaborator as any)._id;
            const collaboratorName = typeof collaborator === 'string' ? 'Usuario' : (collaborator as any).name || 'Usuario';
            
            const performanceRecords = await UserPerformance.find({
              user: collaboratorId,
              task: task._id
            });

            if (performanceRecords.length > 1) {
              this.analysis.issues.push(
                `Tarea ${task.name}: Colaborador ${collaboratorName} tiene m√∫ltiples registros de performance`
              );
              hasIntegrity = false;
            }
          }
        }
      }

      this.analysis.report.tasksWithMultipleCollaborators = multiCollaboratorTasks;
      this.analysis.taskAssignmentIntegrity = hasIntegrity;

      console.log(`  ‚úÖ Tareas analizadas: ${tasks.length}`);
      console.log(`  üìä Tareas con m√∫ltiples colaboradores: ${multiCollaboratorTasks}`);
      console.log(`  ${hasIntegrity ? '‚úÖ' : '‚ùå'} Integridad de asignaci√≥n: ${hasIntegrity ? 'V√ÅLIDA' : 'VIOLADA'}\n`);

    } catch (error) {
      this.analysis.issues.push(`Error en an√°lisis de asignaci√≥n: ${error.message}`);
      console.log('  ‚ùå Error en an√°lisis de asignaci√≥n de tareas\n');
    }
  }

  /**
   * 2. Verificar aislamiento en tracking de performance
   */
  private async analyzePerformanceTrackingIsolation(): Promise<void> {
    console.log('üìä 2. Analizando aislamiento en tracking de performance...');

    try {
      const performanceRecords = await UserPerformance.find({})
        .populate('user', 'name email')
        .populate('task', 'name')
        .populate('project', 'projectName');

      this.analysis.report.performanceRecordsAnalyzed = performanceRecords.length;

      let hasIsolation = true;
      const userTaskCombinations = new Map<string, Set<string>>();

      for (const record of performanceRecords) {
        const userKey = record.user._id.toString();
        const taskKey = record.task._id.toString();
        
        if (!userTaskCombinations.has(userKey)) {
          userTaskCombinations.set(userKey, new Set());
        }

        const userTasks = userTaskCombinations.get(userKey)!;
        if (userTasks.has(taskKey)) {
          const userName = (record.user as any)?.name || 'Usuario desconocido';
          const taskName = (record.task as any)?.name || 'Tarea desconocida';
          this.analysis.issues.push(
            `Performance duplicada: Usuario ${userName} tiene m√∫ltiples registros para tarea ${taskName}`
          );
          hasIsolation = false;
          this.analysis.report.isolationViolations++;
        } else {
          userTasks.add(taskKey);
        }

        // Verificar que los datos de performance sean espec√≠ficos del usuario
        if (!record.user || !record.task || !record.project) {
          this.analysis.issues.push(
            `Registro de performance incompleto: falta referencia a usuario, tarea o proyecto`
          );
          hasIsolation = false;
        }

        // Verificar que el c√°lculo de isOnTime sea independiente
        if (record.isCompleted && record.completionTime != null) {
          // Validar que el c√°lculo no dependa de otros usuarios
          const statusChanges = record.statusChanges;
          const hasValidTimeline = statusChanges.length > 0 && 
            statusChanges.every(change => change.timestamp && change.workingDaysFromStart >= 0);
          
          if (!hasValidTimeline) {
            const userName = (record.user as any)?.name || 'Usuario desconocido';
            const taskName = (record.task as any)?.name || 'Tarea desconocida';
            this.analysis.issues.push(
              `Timeline de performance inv√°lida para usuario ${userName} en tarea ${taskName}`
            );
            hasIsolation = false;
          }
        }
      }

      this.analysis.performanceTrackingIsolation = hasIsolation;

      console.log(`  ‚úÖ Registros de performance analizados: ${performanceRecords.length}`);
      console.log(`  üìà Combinaciones usuario-tarea √∫nicas: ${Array.from(userTaskCombinations.values()).reduce((sum, set) => sum + set.size, 0)}`);
      console.log(`  ‚ö†Ô∏è Violaciones de aislamiento detectadas: ${this.analysis.report.isolationViolations}`);
      console.log(`  ${hasIsolation ? '‚úÖ' : '‚ùå'} Aislamiento de tracking: ${hasIsolation ? 'V√ÅLIDO' : 'VIOLADO'}\n`);

    } catch (error) {
      this.analysis.issues.push(`Error en an√°lisis de aislamiento: ${error.message}`);
      console.log('  ‚ùå Error en an√°lisis de aislamiento de performance\n');
    }
  }

  /**
   * 3. Verificar independencia en c√°lculo de evaluaciones
   */
  private async analyzeEvaluationCalculationIndependence(): Promise<void> {
    console.log('üéØ 3. Analizando independencia en c√°lculo de evaluaciones...');

    try {
      const evaluations = await UserEvaluation.find({})
        .populate('user', 'name email')
        .populate('evaluatedBy', 'name');

      this.analysis.report.evaluationsAnalyzed = evaluations.length;

      let hasIndependence = true;

      for (const evaluation of evaluations) {
        // Verificar que las m√©tricas sean calculadas solo con datos del usuario
        const userPerformance = await UserPerformance.find({
          user: evaluation.user._id,
          createdAt: {
            $gte: evaluation.period.startDate,
            $lte: evaluation.period.endDate
          }
        });

        // Verificar que no haya referencias cruzadas a otros usuarios
        const relatedUsers = await UserPerformance.find({
          project: { $in: userPerformance.map(p => p.project) },
          user: { $ne: evaluation.user._id }
        });

        // Las evaluaciones deben basarse SOLO en el performance del usuario espec√≠fico
        if (evaluation.metrics) {
          const { taskCompletionRate, averageCompletionTime, productivity } = evaluation.metrics;
          
          const completedTasks = userPerformance.filter(p => p.isCompleted);
          const expectedCompletionRate = userPerformance.length > 0 
            ? (completedTasks.length / userPerformance.length) * 100 
            : 0;

          // Verificar que la tasa de completion sea consistente con los datos individuales
          const rateDeviation = Math.abs(taskCompletionRate - expectedCompletionRate);
          if (rateDeviation > 5) { // Tolerancia del 5%
            const userName = (evaluation.user as any)?.name || 'Usuario desconocido';
            this.analysis.issues.push(
              `Evaluaci√≥n de ${userName}: Tasa de completion inconsistente (esperada: ${expectedCompletionRate.toFixed(2)}%, registrada: ${taskCompletionRate}%)`
            );
            hasIndependence = false;
          }
        }
      }

      this.analysis.evaluationCalculationIndependence = hasIndependence;

      console.log(`  ‚úÖ Evaluaciones analizadas: ${evaluations.length}`);
      console.log(`  ${hasIndependence ? '‚úÖ' : '‚ùå'} Independencia de c√°lculo: ${hasIndependence ? 'V√ÅLIDA' : 'VIOLADA'}\n`);

    } catch (error) {
      this.analysis.issues.push(`Error en an√°lisis de independencia: ${error.message}`);
      console.log('  ‚ùå Error en an√°lisis de independencia de evaluaciones\n');
    }
  }

  /**
   * 4. Detectar impacto cruzado entre usuarios
   */
  private async detectCrossUserImpact(): Promise<void> {
    console.log('üîó 4. Detectando impacto cruzado entre usuarios...');

    try {
      let noCrossImpact = true;

      // Verificar que los retrasos de un usuario no afecten a otros
      const projects = await Project.find({}).populate('team manager');

      for (const project of projects) {
        const projectUsers = [
          ...(project.team || []),
          project.manager
        ].filter(Boolean).map(user => user._id.toString());

        const allUserPerformances = await UserPerformance.find({
          project: project._id,
          user: { $in: projectUsers }
        }).populate('user', 'name');

        // Agrupar por usuario
        const userPerformanceMap = new Map<string, any[]>();
        allUserPerformances.forEach(perf => {
          const userId = perf.user._id.toString();
          if (!userPerformanceMap.has(userId)) {
            userPerformanceMap.set(userId, []);
          }
          userPerformanceMap.get(userId)!.push(perf);
        });

        // Verificar que el performance de cada usuario sea independiente
        for (const [userId, performances] of userPerformanceMap) {
          const otherUsersPerformances = Array.from(userPerformanceMap.entries())
            .filter(([otherUserId]) => otherUserId !== userId)
            .flatMap(([, perfs]) => perfs);

          // Verificar que no haya c√°lculos que dependan de otros usuarios
          for (const perf of performances) {
            if (perf.isOnTime === null && perf.isCompleted) {
              const userName = (perf.user as any)?.name || 'Usuario desconocido';
              this.analysis.issues.push(
                `Usuario ${userName}: Performance completada pero isOnTime no calculado independientemente`
              );
              noCrossImpact = false;
            }
          }
        }
      }

      this.analysis.crossUserImpactDetection = noCrossImpact;

      console.log(`  ${noCrossImpact ? '‚úÖ' : '‚ùå'} Sin impacto cruzado: ${noCrossImpact ? 'CONFIRMADO' : 'DETECTADO'}\n`);

    } catch (error) {
      this.analysis.issues.push(`Error en detecci√≥n de impacto cruzado: ${error.message}`);
      console.log('  ‚ùå Error en detecci√≥n de impacto cruzado\n');
    }
  }

  /**
   * 5. Verificar consistencia de datos
   */
  private async checkDataConsistency(): Promise<void> {
    console.log('üîÑ 5. Verificando consistencia de datos...');

    try {
      let isConsistent = true;

      // Verificar que cada tarea completada tenga registros de performance correspondientes
      const completedTasks = await Task.find({ status: 'completed' }).populate('collaborators');

      for (const task of completedTasks) {
        if (task.collaborators && task.collaborators.length > 0) {
          for (const collaborator of task.collaborators) {
            const collaboratorId = typeof collaborator === 'string' ? collaborator : (collaborator as any)._id;
            const collaboratorName = typeof collaborator === 'string' ? 'Usuario' : (collaborator as any).name || 'Usuario';
            
            const performanceRecord = await UserPerformance.findOne({
              user: collaboratorId,
              task: task._id,
              isCompleted: true
            });

            if (!performanceRecord) {
              this.analysis.issues.push(
                `Tarea completada "${task.name}" sin registro de performance para colaborador ${collaboratorName}`
              );
              isConsistent = false;
            }
          }
        }
      }

      // Verificar que no haya registros de performance hu√©rfanos
      const allPerformanceRecords = await UserPerformance.find({});
      for (const record of allPerformanceRecords) {
        const taskExists = await Task.findById(record.task);
        const userExists = await User.findById(record.user);
        
        if (!taskExists || !userExists) {
          this.analysis.issues.push(
            `Registro de performance hu√©rfano: tarea o usuario no existe`
          );
          isConsistent = false;
        }
      }

      this.analysis.dataConsistencyCheck = isConsistent;

      console.log(`  ${isConsistent ? '‚úÖ' : '‚ùå'} Consistencia de datos: ${isConsistent ? 'V√ÅLIDA' : 'VIOLADA'}\n`);

    } catch (error) {
      this.analysis.issues.push(`Error en verificaci√≥n de consistencia: ${error.message}`);
      console.log('  ‚ùå Error en verificaci√≥n de consistencia\n');
    }
  }

  private calculateOverallScore(): void {
    const checks = [
      this.analysis.taskAssignmentIntegrity,
      this.analysis.performanceTrackingIsolation,
      this.analysis.evaluationCalculationIndependence,
      this.analysis.crossUserImpactDetection,
      this.analysis.dataConsistencyCheck
    ];

    this.analysis.overall = checks.every(check => check === true);

    if (this.analysis.overall) {
      this.analysis.recommendations.push('‚úÖ Sistema de evaluaci√≥n completamente independiente');
      this.analysis.recommendations.push('‚úÖ Los retrasos de un colaborador NO afectan a otros');
      this.analysis.recommendations.push('‚úÖ Las evaluaciones son justas e individuales');
    } else {
      this.analysis.recommendations.push('‚ö†Ô∏è Se requieren correcciones para garantizar independencia');
      this.analysis.recommendations.push('üîß Revisar los issues reportados');
    }
  }

  private printDetailedReport(): void {
    console.log(colors.cyan.bold('üìä REPORTE DETALLADO DE INTEGRIDAD\n'));

    console.log('üîç Componentes analizados:');
    console.log(`  Asignaci√≥n de tareas: ${this.getStatusIcon(this.analysis.taskAssignmentIntegrity)}`);
    console.log(`  Tracking de performance: ${this.getStatusIcon(this.analysis.performanceTrackingIsolation)}`);
    console.log(`  C√°lculo de evaluaciones: ${this.getStatusIcon(this.analysis.evaluationCalculationIndependence)}`);
    console.log(`  Impacto cruzado: ${this.getStatusIcon(this.analysis.crossUserImpactDetection)}`);
    console.log(`  Consistencia de datos: ${this.getStatusIcon(this.analysis.dataConsistencyCheck)}\n`);

    console.log('üìà Estad√≠sticas del an√°lisis:');
    console.log(`  üìã Total de tareas: ${this.analysis.report.totalTasks}`);
    console.log(`  üë• Tareas con m√∫ltiples colaboradores: ${this.analysis.report.tasksWithMultipleCollaborators}`);
    console.log(`  üìä Registros de performance: ${this.analysis.report.performanceRecordsAnalyzed}`);
    console.log(`  üéØ Evaluaciones analizadas: ${this.analysis.report.evaluationsAnalyzed}`);
    console.log(`  ‚ö†Ô∏è Violaciones detectadas: ${this.analysis.report.isolationViolations}\n`);

    if (this.analysis.issues.length > 0) {
      console.log(colors.red.bold('‚ùå Issues detectados:'));
      this.analysis.issues.forEach(issue => {
        console.log(colors.red(`  ‚Ä¢ ${issue}`));
      });
      console.log();
    }

    console.log(colors.yellow.bold('üí° Recomendaciones:'));
    this.analysis.recommendations.forEach(rec => {
      console.log(colors.yellow(`  ‚Ä¢ ${rec}`));
    });
    console.log();

    if (this.analysis.overall) {
      console.log(colors.green.bold('üéâ SISTEMA DE EVALUACI√ìN: COMPLETAMENTE INDEPENDIENTE'));
      console.log(colors.green.bold('‚úÖ LAS EVALUACIONES SON JUSTAS E INDIVIDUALES'));
    } else {
      console.log(colors.red.bold('‚ö†Ô∏è SISTEMA REQUIERE CORRECCIONES PARA GARANTIZAR INDEPENDENCIA'));
    }
  }

  private getStatusIcon(status: boolean): string {
    return status ? colors.green('‚úÖ V√ÅLIDO') : colors.red('‚ùå INV√ÅLIDO');
  }
}

// Ejecutar an√°lisis
async function runIndependenceAnalysis() {
  const validator = new PerformanceIndependenceValidator();
  const analysis = await validator.runAnalysis();
  
  process.exit(analysis.overall ? 0 : 1);
}

if (require.main === module) {
  runIndependenceAnalysis();
}

export { PerformanceIndependenceValidator };
